---
alwaysApply: true
---
# Linkart — Cursor Project Rules

> Version: v3.0
> Purpose: Define Cursor AI workspace rules, coding standards, and conventions for Linkart backend and mobile app development. This version adds explicit rules about Supabase-managed migrations, Edge Functions, and the new separated architecture (Products vs Services) with multi-pricing.

---

## 1. General Guidelines

* Cursor AI must always use this document as **project authority** when suggesting, generating, or modifying code.
* All generated code must comply with:

  * The architecture described in `backend_structure_document.mdc`
  * App flow logic defined in `app_flow_document.mdc`
  * Technical stack defined in `linkart.rules.md`
* Prefer clarity, modularity, and maintainability over brevity.
* All features should be designed using a **modular approach** with a clear separation between components, features, and UI primitives.
* **CRITICAL**: Always distinguish between Products (beats/kits payants) and Services (professionnels gratuits) in all code and documentation.

---

## 2. Project Stack Rules

### Frontend (Mobile)

* Framework: **React Native (Expo)**
* Language: **TypeScript**
* UI Library: **NativeBase** (primary)
* Optional: **nativewind** for utility styles
* Styling tokens: **centralized theme system** (from `theme/colors.ts`)
* State management: **Zustand** or **Context API**
* Audio playback: **expo-av**
* File upload: **presigned PUT URLs to R2**
* HTTP requests: **axios** or **fetch wrapper**
* Auth: **Supabase Auth (OTP)**
* Error tracking: **Sentry**

### Backend

* Environment: **Supabase Edge Functions** (Deno) — preferred for Linkart serverless logic.
* Language: **TypeScript / JavaScript**
* DB: **Postgres (Supabase)**
* Storage: **Cloudflare R2** (S3-compatible)
* Auth: **Supabase JWT**
* Monitoring: **Sentry + Supabase logs**

---

## 3. File & Directory Structure

```
linkart/
├── app/
│   ├── components/        # Atoms, Molecules, Organisms
│   ├── features/          # Feature-based folders
│   │   ├── products/      # Beats/kits (payants)
│   │   ├── services/      # Services (gratuits)
│   │   ├── bookings/      # Réservations services
│   │   ├── pricing/       # Multi-pricing (licences + tiers)
│   │   ├── payments/      # Paiements (beats/kits uniquement)
│   │   ├── wallet/        # Wallet (beats/kits uniquement)
│   │   └── messaging/     # Chat (services uniquement)
│   ├── screens/
│   ├── hooks/
│   ├── services/          # API clients
│   ├── store/             # Zustand or Context
│   ├── theme/             # colors.ts, spacing.ts, index.ts
│   └── App.tsx
├── supabase/
│   ├── migrations/        # SQL migrations managed by Supabase CLI
│   ├── functions/         # Supabase Edge Functions (each folder is a function)
│   │   ├── products/      # Product-related functions
│   │   ├── services/      # Service-related functions
│   │   ├── bookings/      # Booking functions
│   │   ├── pricing/       # Pricing functions
│   │   └── payments/      # Payment functions
├── docs/
└── .env
```

> **Note:** `supabase/` is the canonical place for migrations and functions. Cursor must update files there when changing DB schema or server-side logic.

---

## 4. Database Architecture Rules (CRITICAL)

### 4.1 Products vs Services Separation

* **NEVER** mix Products and Services in the same table or logic.
* **Products** (beats/kits/samples) are **PAID** and generate **5% commission**.
* **Services** (mixage/mastering/recording) are **FREE** and generate **0% commission**.
* Always use separate tables: `products` + `product_pricing` vs `services` + `service_pricing`.

### 4.2 Multi-Pricing Rules

* **Products**: Always use `product_pricing` table for prices. NEVER store price directly in `products` table.
* **Services**: Always use `service_pricing` table for prices. Support multiple tiers per service.
* **Transactions**: Always reference `pricing_id` (from product_pricing), NEVER reference services.
* **API Endpoints**: Always include pricing selection in purchase/booking flows.

### 4.3 Database Constraints

* `transactions.product_id` must reference `products.id` ONLY (never services).
* `transactions.pricing_id` must reference `product_pricing.id`.
* `bookings.service_id` must reference `services.id` ONLY.
* `bookings.pricing_tier_id` must reference `service_pricing.id` (nullable for on-demand).
* `ratings` must have either `product_id` OR `booking_id` (never both).

### 4.4 Required Migrations

When creating new features, Cursor must create migrations for:

* `products` + `product_pricing` tables
* `services` + `service_pricing` tables  
* `bookings` + `conversations` + `messages` tables
* Proper foreign key constraints and indexes
* RLS policies for all new tables

---

## 5. Theming and Design Tokens

* All colors, fonts, and spacings must come from `app/theme/colors.ts` and `theme/index.ts`.
* Never hardcode colors or typography in components.
* The theme must support **light** and **dark** variants.
* `NativeBase`’s `extendTheme()` is used to apply the theme globally via `NativeBaseProvider`.

**Example:**

```ts
export const colors = {
  primary: '#1E40AF',
  accent: '#F59E0B',
  background: '#FFFFFF',
  surface: '#F8FAFC',
  text: '#0F172A',
  muted: '#64748B',
  danger: '#EF4444',
};
```

---

## 6. Supabase: Migrations & Edge Functions (Key Rules)

This section is new and mandatory. Supabase is the authoritative source for DB schema and Edge Functions. Cursor must follow these rules strictly.

### 6.1 Migrations

* All schema changes **must** be made as SQL migrations inside `supabase/migrations/` or via `supabase db diff` / `supabase db push` workflow.
* **Use the Supabase CLI command** to create new migrations:

  ```bash
  supabase migration new "descriptive_name"  # creates a timestamped migration file
  ```

  This ensures consistent timestamped filenames. Example: `20251022123000_create_ratings_table.sql`.
* Migration filenames must be timestamped and descriptive: `YYYYMMDDHHMMSS_create_products.sql` or `20251022120000_add_ratings_table.sql`.
* **Never** modify `schema.sql` directly in production without creating a migration.
* For any DB change, Cursor must:

  1. Add a new migration file to `supabase/migrations/` using `supabase migration new`.
  2. Update `supabase/schema.sql` (if using canonical schema).
  3. Include a SQL rollback section where feasible.
  4. Add tests or describe manual DB checks in the PR description.
* Migrations must be idempotent (use `IF NOT EXISTS` for create statements when reasonable).
* **TypeScript DB types generation:** after applying migrations or updating schema, generate TypeScript types from the database so Edge Functions and frontend have typed contracts.

  * Example command (remote project):

    ```bash
    supabase gen types typescript --project-ref $SUPABASE_REF --schema public > src/types/supabase.ts
    ```
  * Example command (local):

    ```bash
    supabase gen types typescript --local > src/types/supabase.ts
    ```
  * Cursor MUST regenerate and commit the generated types whenever the DB schema changes. Use these types in Edge Functions and frontend code:

    ```ts
    import type { Database } from '../types/supabase'
    import { createClient } from '@supabase/supabase-js'

    const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY)
    ```

### 6.2 Edge Functions

* Place Edge Functions in `supabase/functions/<function-name>/index.ts` (Deno-compatible).
* Each function folder must include a README explaining purpose, input/output JSON examples, required env vars, and capabilities required.
* Local development: use `supabase functions serve` to run functions locally. Cursor must provide a tested function before creating a PR.
* When modifying an Edge Function that interacts with R2, use `lib/r2.ts` helper to centralize R2 client usage.

### 6.3 CI/CD for Supabase

* Use GitHub Actions to deploy migrations and functions:

  * On `main` merge: run `supabase db push --project-ref $SUPABASE_REF` and `supabase functions deploy --project-ref $SUPABASE_REF --no-verify` (or equivalent).
  * Protect the production branch and require code review for migrations.
* Runner must use `SUPABASE_SERVICE_ROLE_KEY` only in CI secrets (not in PRs from forks).

### 6.4 Local dev & testing

* Developers should run `supabase start` (or `supabase functions serve`) and a local Postgres if needed.
* Cursor must include minimal integration test for functions that mutate DB (using test DB or mock client).
* Avoid destructive commands (`supabase db reset`) on production-like environments.

---

## 7. API Standards

* All endpoints must use JSON.
* Return consistent structure with `success`, `data`, and `error` keys.
* HTTP status codes:

  * 200 Success
  * 201 Created
  * 400 Bad request
  * 401 Unauthorized
  * 403 Forbidden (missing capability)
  * 404 Not found
  * 500 Internal error

### 7.1 Product Endpoints (beats/kits)

* `POST /api/pay` - MUST include `pricing_id` parameter
* `GET /api/products/:id/pricing` - Returns all available licenses
* All product endpoints must validate `can_sell` capability

### 7.2 Service Endpoints (professionnels)

* `POST /api/bookings/create` - MUST include `service_id` and optional `pricing_tier_id`
* `GET /api/services/:id/pricing` - Returns all available tiers
* All service endpoints must validate `can_offer_services` capability

### 7.3 Messaging Endpoints (services uniquement)

* `POST /api/conversations/:id/messages` - Only for confirmed bookings
* `GET /api/conversations/:id/messages` - Only for booking participants

---

## 8. Modular Architecture Rules

* Each **feature** must have its own folder in `/features/` (e.g. `features/products`, `features/services`, `features/bookings`).
* **CRITICAL**: Never mix product and service logic in the same feature folder.
* Shared UI primitives live in `/components/atoms` and `/components/molecules`.
* Larger composite sections (cards, product forms) are in `/components/organisms`.
* Features can only depend on:

  * components
  * hooks
  * services
  * theme
* No circular imports.
* **Pricing components** must be shared between products and services but handle different data structures.

---

## 9. Security & Error Handling

* Use **try/catch** everywhere network calls occur.
* Log all caught errors with Sentry.
* Never expose keys or tokens client-side.
* Presigned URLs only for upload/download.
* TTLs:

  * Upload: 5min
  * Download: 15min

### 9.1 Payment Security (beats/kits uniquement)

* **NEVER** allow payment endpoints to process service bookings.
* Always validate `pricing_id` belongs to `product_id` before processing payment.
* Escrow system: hold funds until manual/admin release.

### 9.2 Messaging Security (services uniquement)

* **NEVER** allow messaging between product buyers and sellers.
* Only allow messaging for confirmed service bookings.
* Rate limit: max 50 messages/hour per conversation.

---

## 10. Version Control & CI/CD

* Branch naming: `feat/`, `fix/`, `api/`, `chore/`.
* Commits: Conventional Commits style.
* Auto-deploy to Supabase Edge and Expo EAS on `main` (after PR approvals).
* Pre-commit lint & test via GitHub Actions.

---

## 11. Testing Rules

| Layer       | Tool         | Goal                                 |
| :---------- | :----------- | :----------------------------------- |
| Unit        | Jest         | Verify business logic                |
| Integration | Supertest    | Validate API endpoints               |
| E2E         | Playwright   | Test flows upload → buy → download   |
| E2E Services| Playwright   | Test flows booking → messaging → completion |
| UI          | Storybook RN | Build and verify reusable components |

Test results must be green before deployment to production.

### 11.1 Multi-Pricing Tests

* Test different license types for products (basic, exclusive, non-exclusive, lease).
* Test different tiers for services (fixed price, on-demand, multi-tier).
* Test pricing validation in payment flows.
* Test booking flows with different pricing options.

---

## 12. Cursor AI Behaviors

* Cursor must prioritize modular code generation and proper imports.
* Always use existing helpers (`lib/r2.ts`, `lib/payment.ts`).
* Never hardcode credentials.
* Must enforce 5% commission rule in all payment-related flows (beats/kits uniquement).
* Must validate user `capabilities` for all protected endpoints.
* Suggest test coverage when creating new features.
* Use theme tokens for any UI component.
* When changing DB schema, Cursor must generate a SQL migration and add it to `supabase/migrations/`.
* When adding or editing server logic, Cursor must add/update the corresponding Edge Function under `supabase/functions/` and a README for the function.

### 12.1 Critical Rules for Products vs Services

* **NEVER** create payment flows for services.
* **NEVER** create messaging flows for products.
* **ALWAYS** use separate tables for products and services.
* **ALWAYS** include pricing selection in purchase/booking flows.
* **ALWAYS** validate pricing_id belongs to the correct entity.

---

## 13. NativeBase & Theming Rules

* All screens wrapped with `NativeBaseProvider` and `SafeAreaView`.
* Custom components use `useTheme()` hook for consistent color and spacing.
* Common variants: `ButtonPrimary`, `InputField`, `Card`, `Badge`, `Avatar`.
* Use color tokens and font scale defined in theme.
* When possible, abstract repetitive patterns into hooks or reusable components.

---

## 14. Future Enhancements

* Add multi-theme switching (dark/light)
* Add Storybook RN integration
* Generate automatic docs for API endpoints
* Add continuous design token sync between mobile/web
