---
alwaysApply: true
---
# Cursor Rules — Operational & Prompting Guide for Linkart

> Version: v2.1
> Purpose: Provide precise operational rules, prompting conventions and do/don'ts for Cursor AI when working on the Linkart codebase. This file complements `cursor_project_rules.mdc` and is intended to be the single source-of-truth for Cursor's behavior, prompts format, CI interactions and production safety.
> 
> **Architecture v2.1**: Séparation claire entre Products (beats/kits payants) et Services (professionnels gratuits) avec système multi-pricing pour les deux. Ajout du Design System v2.0, système de favoris et playlists éditoriales.

---

## 1. Scope & Intent

This document tells Cursor exactly how to behave when editing Linkart source code, DB schema and infra files. It is *strict*. Cursor must follow these rules when generating code, migrations, documentation, tests, or PRs.

Cursor must treat this file as **authoritative** and check it before producing outputs.

---

## 2. High-level rules (non-negotiable)

1. **Never** make change that bypasses RLS, capability checks or security constraints.
2. **Always** generate a timestamped Supabase migration using `supabase migration new "desc"` for DB schema changes and commit it.
3. **Always** regenerate TypeScript DB types after any schema migration and commit them (`supabase gen types typescript ...`).
4. **Never** embed secrets/keys in code. Use env variables and reference `process.env` or `Deno.env.get` as appropriate.
5. **All** payment logic must enforce the **5% commission** for sales and 0% for boosts; do not alter this rule unless asked explicitly by the human.
6. **All** file access must use presigned URLs (R2). No proxying of file contents through the app server by default.
7. **Always** add tests for new logic (unit or integration) and description in PR.
8. **All** Edge Functions must include a README header describing purpose, input, output, env vars, and required capabilities.
9. **CRITICAL**: Always distinguish between Products (beats/kits payants) and Services (professionnels gratuits) in all code and documentation.
10. **CRITICAL**: Never mix product and service logic in the same feature folder or Edge Function.
11. **CRITICAL**: All pricing logic must use separate tables (`product_pricing` for products, `service_pricing` for services).
12. **CRITICAL**: Services are NEVER purchasable via `/api/pay` - they use booking system only.
13. **CRITICAL**: Design System v2.0 must be followed for all UI components - see `docs/product/design-system.md`.
14. **CRITICAL**: HeartIcon and PlayButton are mandatory for Product Cards and Mini Player.
15. **CRITICAL**: Playlists are admin-only (editorial) - users cannot create/modify playlists.
16. **CRITICAL**: Favorites system must use optimistic UI with rollback on error.

---

## 3. Prompting Format (how humans must provide tasks to Cursor)

To get consistent outputs from Cursor, use the following structured prompt pattern. Cursor will refuse prompts that do not use the pattern for code-level changes.

### 3.1 Minimal required template

```md
#context
<short, relevant context or a link to the .mdc spec this change relates to>

#task
<clear single task description — e.g. 'Add ratings table and API endpoints'>

#constraints
- list constraints (DB command required, TTL values, capability check etc.)

#output
- files to modify (paths)
- tests to add
- brief PR description
```

### 3.2 Example

```md
#context
Update to support user ratings for products. See backend_structure_document.mdc -> Ratings section.

#task
Create SQL migration to add `ratings` table, generate types, and add Edge Function `ratings/create` (Deno) to allow authenticated users to submit a rating after purchase.

#constraints
- Use `supabase migration new "add_ratings_table"` to create migration file.
- Enforce `score` between 1 and 5.
- Only allow insert if user purchased product (backend must validate transaction exists and status=paid).

#output
- supabase/migrations/<timestamp>_add_ratings_table.sql
- supabase/functions/ratings-create/index.ts
- unit test file for ratings function
- update src/types/supabase.ts (regenerated)
- PR description with DB checks and manual test steps
```

Cursor must follow this template and return the exact artifacts requested in `#output`.

---

## 4. File generation & edits rules

* **Migrations**: create via `supabase migration new "desc"`. Add SQL only in the generated file. Do not edit other migration files.
* **Types**: run `supabase gen types typescript --local > src/types/supabase.ts` and commit. If CI detects mismatched types, the PR must be fixed.
* **Edge Functions**: create function folder under `supabase/functions/<name>/` with `index.ts` entry and `README.md` describing inputs/outputs/env/capabilities. Use Deno style (no Node-only libs unless using Vercel).
* **Helpers**: use central helpers in `backend/lib/` or `supabase/functions/_shared/` for R2, pdf, and payment logic. Don’t duplicate code.

---

## 5. Architecture Rules (Products vs Services)

### 5.1 Database Separation Rules

* **Products Table**: `products` - beats, kits, samples (payants, commission 5%)
* **Services Table**: `services` - professionnels gratuits (0% commission)
* **Product Pricing**: `product_pricing` - multi-licences (basic, non_exclusive, exclusive, lease)
* **Service Pricing**: `service_pricing` - multi-tiers (prix fixe, à la demande, multi-tiers)
* **Transactions**: ONLY reference `products.id` and `product_pricing.id` - NEVER services
* **Bookings**: ONLY reference `services.id` and `service_pricing.id` - NEVER products

### 5.2 API Endpoint Rules

* **Product Endpoints**: `/api/products/*`, `/api/pay` (beats/kits uniquement)
* **Service Endpoints**: `/api/services/*`, `/api/bookings/*` (services uniquement)
* **Messaging**: `/api/conversations/*`, `/api/messages/*` (services uniquement)
* **Pricing Endpoints**: `/api/products/:id/pricing`, `/api/services/:id/pricing`

### 5.3 Frontend Feature Rules

* **Product Features**: `src/features/products/`, `src/features/payments/`, `src/features/wallet/`
* **Service Features**: `src/features/services/`, `src/features/bookings/`, `src/features/messaging/`
* **Shared Features**: `src/features/pricing/` (handles both product and service pricing)

### 5.4 Edge Function Rules

* **Product Functions**: `supabase/functions/products/`, `supabase/functions/payments/`
* **Service Functions**: `supabase/functions/services/`, `supabase/functions/bookings/`, `supabase/functions/conversations/`
* **Shared Functions**: `supabase/functions/pricing/` (handles both types)

---

## 6. Security & privacy rules

* Env secrets must be referenced only via `process.env` (Node) or `Deno.env.get` (Deno) and never printed in logs.
* For dev examples, use placeholders like `SUPABASE_SERVICE_ROLE_KEY_PLACEHOLDER` — never real keys.
* When creating presigned URLs include TTL constants: upload 5min, download 15min.
* Sanitize any user-provided strings before inserting into SQL (use parameterized queries).
* All endpoints that modify state must verify JWT and capabilities. Respond with 403 if missing.
* **Payment Security**: `/api/pay` must validate `pricing_id` belongs to the product and reject service purchases.
* **Messaging Security**: Chat only allowed for confirmed service bookings, never for products.
* **Pricing Validation**: Always verify `pricing_id` exists and is available before processing transactions.

---

## 7. Testing & CI integration

* Cursor must produce tests when adding functionality. Tests should run locally and in GitHub Actions.
* **Multi-pricing tests**: Required for any pricing-related changes (products or services).
* **Product/Service separation tests**: Required for any changes affecting the separation.
* **Booking system tests**: Required for any booking/messaging changes.

* Add a CI step to regenerate and compare DB types; fail CI if changed types were not committed. Example GH job steps:

  1. `supabase gen types typescript --local > tmp/types.ts`
  2. `git diff --exit-code tmp/types.ts src/types/supabase.ts || (echo 'Types changed — regenerate and commit' && exit 1)`

* For migrations: CI runs `supabase db push --project-ref $SUPABASE_REF` only in protected deploy step; PRs must not run destructive commands.

---

## 8. Code review & PR requirements

Every PR generated by Cursor must include:

* Title with `[feat]`, `[fix]` prefix.
* Clear description linking to the relevant `.mdc` docs.
* List of changed files and rationale.
* Migration files added (if any).
* Generated types committed.
* Tests added and passing locally.
* **Multi-pricing tests** (if pricing-related changes).
* **Product/Service separation tests** (if architecture changes).
* **Booking system tests** (if booking/messaging changes).
* Manual QA steps to validate (for payments or admin flows).

No PR can be merged without at least one human approving the migration and the Edge Function README.

---

## 9. Operational rules (runtime)

* Cursor must not suggest running `supabase db reset` in environments with data.
* For additive maintenance tasks (e.g., reindexing), Cursor must provide safe SQL (wrapped in transaction).
* When writing data migration SQL (backfills), Cursor must generate idempotent scripts and include a `WHERE` guard and small preview SELECT to verify row counts.
* **Pricing Validation**: Always verify pricing exists and is available before processing.
* **Service Booking**: Always validate booking status before allowing messaging.
* **Product Purchase**: Always validate pricing_id belongs to the product before processing payment.

---

## 10. Prompt examples for common tasks

### 10.1 Add new migration

```
#context
Add ratings table.
#task
Create migration using supabase migration new "add_ratings_table" with SQL to create ratings table.
#constraints
- rating score int 1-5
- reference transactions optional
#output
- supabase/migrations/<timestamp>_add_ratings_table.sql
```

### 10.2 Create Edge Function

```
#context
Create Edge Function to generate presigned upload URL
#task
Add function supabase/functions/upload-request/index.ts which validates can_sell and returns PUT URL.
#constraints
- use lib/r2.ts helper
- TTL 5min
#output
- supabase/functions/upload-request/index.ts
- supabase/functions/upload-request/README.md
- test file
```

### 10.3 Add Product Pricing

```
#context
Add multi-licensing for products (beats/kits).
#task
Create migration using supabase migration new "add_product_pricing" with SQL to create product_pricing table.
#constraints
- reference products.id
- license_type enum (basic, non_exclusive, exclusive, lease)
- price int, terms text, is_available boolean
#output
- supabase/migrations/<timestamp>_add_product_pricing.sql
- supabase/functions/products/pricing/index.ts
- test file for pricing validation
```

### 10.4 Add Service Booking

```
#context
Add booking system for services (professionnels gratuits).
#task
Create migration using supabase migration new "add_service_booking" with SQL to create bookings and conversations tables.
#constraints
- reference services.id and service_pricing.id
- status enum (pending, confirmed, completed, cancelled)
- messaging only for confirmed bookings
#output
- supabase/migrations/<timestamp>_add_service_booking.sql
- supabase/functions/bookings/create/index.ts
- supabase/functions/conversations/create/index.ts
- test files for booking flow
```

### 10.5 Add Favorites System

```
#context
Add favorites system for beats (users can like/unlike products).
#task
Create migration using supabase migration new "add_favorites_table" with SQL to create favorites table.
#constraints
- reference users.id and products.id
- unique constraint (user_id, product_id)
- RLS policies for user access only
#output
- supabase/migrations/<timestamp>_add_favorites_table.sql
- supabase/functions/favorites/toggle/index.ts
- src/components/atoms/HeartIcon.tsx
- src/store/favoritesStore.ts
- test files for favorites flow
```

### 10.6 Add Editorial Playlists

```
#context
Add editorial playlists system (admin-only creation, user consumption).
#task
Create migration using supabase migration new "add_playlists_system" with SQL to create playlists and playlist_items tables.
#constraints
- playlists.created_by must be admin users only
- playlist_items reference playlists.id and products.id
- RLS policies: users can read published playlists, admins can manage all
#output
- supabase/migrations/<timestamp>_add_playlists_system.sql
- supabase/functions/admin/playlists/create/index.ts
- supabase/functions/playlists/list/index.ts
- src/components/molecules/PlaylistCard.tsx
- test files for playlists flow
```

---

## 11. Escalation & human checks

Cursor must flag the following for human review:

* Any change to payment flows or commission logic.
* Any change to RLS policies.
* Any data migration that modifies existing rows in production tables.
* Anything that touches user funds (wallet, withdrawals).
* Any change to product/service separation logic.
* Any change to pricing validation logic.
* Any change to booking/messaging restrictions.
* Any change to design system components (HeartIcon, PlayButton).
* Any change to favorites system logic.
* Any change to playlists system (admin-only restrictions).

When flagged, Cursor must produce a short risk summary and suggested rollback steps.

---

## 12. Versioning & change log

* Cursor must add a one-paragraph changelog entry at the top of any PR altering the codebase, migrations or functions.
* Keep `cursor_rules.mdc` under source control and update version when rules change.
* **v2.1**: Added design system rules, favorites system rules, and editorial playlists rules.

---

## 13. Acceptance

By using Cursor with this repository, Cursor acknowledges these rules and must follow them strictly. If the user requests a change that violates these rules, Cursor must refuse and explain why, then present alternative safe options.

**CRITICAL**: These rules are non-negotiable and must be followed for all code generation, migrations, and documentation. The separation between Products (beats/kits payants) and Services (professionnels gratuits) is fundamental to the architecture and must never be compromised. The Design System v2.0, favorites system, and editorial playlists are core features that must be implemented according to specifications.


